<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>VR HUD — Interstellar Comet Passports (1I • 2I • 3I)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no">
<meta name="theme-color" content="#04060a">
<style>
  :root{--bg:#04060a;--panel:#08141c;--mint:#aee8ff;--grid:#00aa55}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--mint);font-family:ui-monospace,Consolas,Monaco,monospace}

  /* ВЕРХНЕЕ МЕНЮ (и как DOM-overlay в VR, если доступно) */
  #ui{position:fixed;top:12px;left:50%;transform:translateX(-50%);z-index:2000;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  #ui .seg{display:flex;gap:6px;background:#0a1018;border:1px solid rgba(174,232,255,.25);padding:6px 10px;border-radius:10px}
  #ui button{padding:6px 12px;border-radius:8px;border:1px solid rgba(174,232,255,.35);background:#0e1720;color:var(--mint);cursor:pointer}
  #ui button.active{background:#123040;border-color:#45c0d4;color:#dff8ff}
  #ui .small{padding:6px 10px}

  /* Кнопка входа в VR — снизу по центру */
  #vrDock{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);z-index:2000}
  #overlayWarn{position:fixed;right:12px;bottom:12px;z-index:2000;background:#0a1018;border:1px solid rgba(174,232,255,.25);
               padding:8px 12px;border-radius:10px;opacity:.9;display:none}

  /* Канвас рендера всегда под UI и НЕ ловит клики в десктопе */
  #glcanvas{position:fixed;inset:0;z-index:1;pointer-events:none}

  canvas{display:block}
</style>
</head>
<body>
  <!-- HTML-UI (в очках останется поверх, если доступен DOM overlay) -->
  <div id="ui">
    <div class="seg" id="cometButtons">
      <button data-id="1I" class="active">1I/ʻOumuamua</button>
      <button data-id="2I">2I/Borisov</button>
      <button data-id="3I">3I/ATLAS</button>
    </div>
    <div class="seg">
      <button id="btnZoomOut" class="small">Zoom −</button>
      <button id="btnZoomIn"  class="small">Zoom +</button>
      <button id="btnBig"     class="small">BIG MODE: OFF</button>
      <button id="btnRecenter" class="small">Recenter</button>
    </div>
  </div>
  <div id="vrDock"></div>
  <div id="overlayWarn">DOM overlay is not available — using 3D menu.</div>

  <!-- THREE (только core, без examples/jsm) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* =========================================================
   1) HUD CANVAS (твои графики + анимация заливки)
   ========================================================= */
const SCALE=1.25, HUD_W=Math.round(1536*SCALE), HUD_H=Math.round(864*SCALE), PAD=Math.round(28*SCALE);
const hudCanvas=document.createElement('canvas'); hudCanvas.width=HUD_W; hudCanvas.height=HUD_H;
const g=hudCanvas.getContext('2d');

const anim={dur:1000,start:0,active:false};
const easeOut=x=>1-Math.pow(1-x,3);
const trigger=now=>{anim.start=now;anim.active=true;};

const PASSPORTS={
  "1I":{id:"1I",name:"ʻOumuamua",
    composition:[{label:"Organics (surface proxy)",value:70},{label:"H₂O (UL, visible)",value:3},{label:"CO (UL, visible)",value:2}],
    spectrum:[{lambda:388,label:"CN",val:0.05},{lambda:405,label:"C₃",val:0.03}],
    velocity:{value:26.30,max:100,unit:"km/s",ticks:[.25,.5,.75]},
    mass:{value:0.10,unit:"rel."}, coolness:{value:92,max:100},
    reliability:{measured:0.10,upper:0.20,inferred:0.70}
  },
  "2I":{id:"2I",name:"Borisov",
    composition:[{label:"H₂O",value:100},{label:"CO",value:150}],
    spectrum:[{lambda:388,label:"CN",val:1.00},{lambda:405,label:"C₃",val:0.55},{lambda:516.5,label:"C₂",val:0.70}],
    velocity:{value:32.70,max:100,unit:"km/s",ticks:[.25,.5,.75]},
    mass:{value:0.55,unit:"rel."}, coolness:{value:85,max:100},
    reliability:{measured:0.70,upper:0.10,inferred:0.20}
  },
  "3I":{id:"3I",name:"ATLAS (C/2023 A3)",
    composition:[{label:"H₂O",value:120},{label:"CO₂",value:110}],
    spectrum:[{lambda:388,label:"CN",val:0.60},{lambda:405,label:"C₃",val:0.40},{lambda:516.5,label:"C₂",val:0.70}],
    velocity:{value:63.00,max:100,unit:"km/s",ticks:[.25,.5,.75]},
    mass:{value:0.35,unit:"rel."}, coolness:{value:78,max:100},
    reliability:{measured:0.55,upper:0.15,inferred:0.30}
  }
};
let current=PASSPORTS["1I"];

function frame(ctx,x,y,w,h,title){
  ctx.save();
  ctx.fillStyle='#08141c'; ctx.globalAlpha=.92; ctx.fillRect(x,y,w,h); ctx.globalAlpha=1;
  ctx.strokeStyle='#00aa55'; ctx.lineWidth=2; ctx.setLineDash([8,6]); ctx.strokeRect(x+.5,y+.5,w-1,h-1); ctx.setLineDash([]);
  if(title){ ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`; ctx.fillText(title,x+10,y+22*SCALE); }
  ctx.restore();
}
function capsules(ctx,x,y,w,h,rows,p){
  const top=26*SCALE, gap=18*SCALE, bh=(h-top-24*SCALE-gap*(rows.length-1))/rows.length;
  ctx.save(); ctx.translate(x,y);
  rows.forEach((row,i)=>{
    const yy=top+i*(bh+gap);
    const perc=Math.max(0,Math.min(1,row.value/150));
    const rx=90*SCALE, rw=Math.max(16*SCALE,(w-120*SCALE)*perc*p), rh=bh;

    ctx.strokeStyle='rgba(0,224,255,.10)'; ctx.lineWidth=1;
    for(let gx=0;gx<w-100*SCALE;gx+=80*SCALE){ ctx.beginPath(); ctx.moveTo(gx,yy); ctx.lineTo(gx,yy+rh); ctx.stroke(); }

    const grad=ctx.createLinearGradient(0,yy,w-100*SCALE,yy);
    grad.addColorStop(0,'rgba(120,240,255,.25)'); grad.addColorStop(.5,'rgba(160,250,255,.85)'); grad.addColorStop(1,'rgba(120,240,255,.25)');
    ctx.fillStyle=grad; ctx.strokeStyle='rgba(120,240,255,.6)';
    const r=Math.min(14*SCALE,rh/2);
    ctx.beginPath();
    ctx.moveTo(rx+r,yy); ctx.lineTo(rx+rw-r,yy); ctx.quadraticCurveTo(rx+rw,yy,rx+rw,yy+r);
    ctx.lineTo(rx+rw,yy+rh-r); ctx.quadraticCurveTo(rx+rw,yy+rh,rx+rw-r,yy+rh);
    ctx.lineTo(rx+r,yy+rh); ctx.quadraticCurveTo(rx,yy+rh,rx,yy+rh-r);
    ctx.lineTo(rx,yy+r); ctx.quadraticCurveTo(rx,yy,rx+r,yy); ctx.closePath(); ctx.fill(); ctx.stroke();

    ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`;
    ctx.textAlign='left'; ctx.fillText(row.label, 8, yy+rh*.68);
    ctx.textAlign='right'; ctx.fillText((row.value*p).toFixed(row.value<10?1:0), rx+rw, yy+rh*.68); ctx.textAlign='left';
  });
  ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(16*SCALE)}px ui-monospace,monospace`;
  ctx.fillText('Relative to water = 100 (HST/COS)', 8, h-6*SCALE);
  ctx.restore();
}
function spectrum(ctx,x,y,w,h,lines,p){
  ctx.save(); ctx.translate(x,y);
  const ax=52*SCALE, ay=26*SCALE, gw=w-ax-16*SCALE, gh=h-ay-26*SCALE;
  ctx.strokeStyle='rgba(0,224,255,.15)'; ctx.lineWidth=1;
  for(let gx=0;gx<=gw;gx+=80*SCALE){ ctx.beginPath(); ctx.moveTo(ax+gx,ay); ctx.lineTo(ax+gx,ay+gh); ctx.stroke(); }
  ctx.strokeStyle='rgba(0,224,255,.35)'; ctx.beginPath(); ctx.moveTo(ax,ay+gh); ctx.lineTo(ax+gw,ay+gh); ctx.stroke();
  const Ls=lines.map(l=>l.lambda), Lmin=Math.min(...Ls)-5, Lmax=Math.max(...Ls)+5;
  const sx=λ=> ax+(λ-Lmin)/(Lmax-Lmin)*gw;
  lines.forEach(l=>{
    const lx=sx(l.lambda), hRel=Math.max(.2,Math.min(1,l.val))*p, top=ay+gh*(1-hRel);
    ctx.strokeStyle='rgba(160,250,255,.95)'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(lx,ay+gh); ctx.lineTo(lx,top); ctx.stroke();
    ctx.fillStyle='rgba(160,250,255,.95)'; ctx.beginPath(); ctx.arc(lx,top,5*SCALE,0,Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(lx+6*SCALE, top-8*SCALE); ctx.rotate(-.24); ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(16*SCALE)}px ui-monospace,monospace`;
    ctx.fillText(`${l.label} (${l.lambda} nm)`,0,0); ctx.restore();
  });
  ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(16*SCALE)}px ui-monospace,monospace`; ctx.fillText('λ, nm', ax+gw-40*SCALE, ay+gh+20*SCALE);
  ctx.restore();
}
function donut(ctx,x,y,w,h,value,max,unit,ticks=[],title=null,p=1){
  ctx.save(); ctx.translate(x,y);
  if(title){ ctx.fillStyle='#5fd7ff'; ctx.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`; ctx.fillText(title,8,18*SCALE); }
  const cx=w*.5, cy=h*.52, R=Math.min(w,h)*.32, T=Math.max(20*SCALE,R*.22);
  ctx.strokeStyle='rgba(0,168,160,.35)'; ctx.lineWidth=T; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
  const r=Math.max(0,Math.min(1,(Math.abs(value)/max)*p)), a0=-Math.PI/2, a1=a0 + r*Math.PI*2;
  const grad=ctx.createLinearGradient(cx-R,cy,cx+R,cy); grad.addColorStop(0,'#7fe7ff'); grad.addColorStop(1,'#45c0d4');
  ctx.strokeStyle=grad; ctx.lineWidth=T; ctx.lineCap='round'; ctx.beginPath(); ctx.arc(cx,cy,R,a0,a1); ctx.stroke();
  ctx.strokeStyle='rgba(160,240,255,.6)'; ctx.lineWidth=5;
  ticks.forEach(t=>{ const a=a0+t*Math.PI*2, r1=R-T*.55, r2=R-T*.1; ctx.beginPath(); ctx.moveTo(cx+Math.cos(a)*r1,cy+Math.sin(a)*r1); ctx.lineTo(cx+Math.cos(a)*r2,cy+Math.sin(a)*r2); ctx.stroke(); });
  const shown=Math.abs(value)*p;
  ctx.fillStyle='#aee8ff'; ctx.font=`bold ${Math.round(26*SCALE)}px ui-monospace,monospace`;
  const txt=`${shown.toFixed(2)} ${unit}`; const tw=ctx.measureText(txt).width; ctx.fillText(txt,cx-tw/2,cy+10*SCALE);
  ctx.font=`${Math.round(16*SCALE)}px ui-monospace,monospace`;
  const pct=Math.round((shown/max)*100), sub=`${pct}% of ${max} ${unit}`; const stw=ctx.measureText(sub).width; ctx.fillText(sub,cx-stw/2,cy+30*SCALE);
  ctx.restore();
}
function massBar(ctx,x,y,w,h,val,p){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle='#5fd7ff'; ctx.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`; ctx.fillText('Mass (estimate)',8,18*SCALE);
  const ax=60*SCALE, ay=28*SCALE, gw=w-ax-20*SCALE, gh=h-ay-28*SCALE;
  ctx.strokeStyle='rgba(0,224,255,.25)'; ctx.strokeRect(ax,ay,gw,gh);
  ctx.fillStyle='rgba(160,250,255,.85)'; const hh=Math.max(6*SCALE, gh*val*p);
  ctx.fillRect(ax+20*SCALE, ay+gh-hh, gw-40*SCALE, hh);
  ctx.restore();
}
function reliabilityStack(ctx,x,y,w,h,r,p){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle='#5fd7ff'; ctx.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`; ctx.fillText('Data reliability',8,18*SCALE);
  const ax=60*SCALE, ay=28*SCALE, gw=w-ax-20*SCALE, gh=h-ay-28*SCALE;
  const total=Math.max(1e-6,r.measured+r.upper+r.inferred), m=(r.measured/total)*p, u=(r.upper/total)*p, i=(r.inferred/total)*p;
  const x0=ax+20*SCALE, barW=gw-40*SCALE, y0=ay+20*SCALE, bh=gh-40*SCALE;
  ctx.fillStyle='rgba(0,224,255,.08)'; ctx.fillRect(x0,y0,barW,bh);
  let cur=x0; ctx.fillStyle='rgba(120,240,255,.85)'; const wm=barW*m; ctx.fillRect(cur,y0,wm,bh); cur+=wm;
  ctx.fillStyle='rgba(120,200,255,.65)'; const wu=barW*u; ctx.fillRect(cur,y0,wu,bh); cur+=wu;
  ctx.fillStyle='rgba(80,180,235,.55)'; const wi=barW*i; ctx.fillRect(cur,y0,wi,bh);
  ctx.fillStyle='#aee8ff'; ctx.font=`${Math.round(16*SCALE)}px ui-monospace,monospace`;
  ctx.fillText(`Measured: ${(m*100).toFixed(0)}%`, x0, y0+bh+20*SCALE);
  ctx.fillText(`Upper Limit: ${(u*100).toFixed(0)}%`, x0+180*SCALE, y0+bh+20*SCALE);
  ctx.fillText(`Inference: ${(i*100).toFixed(0)}%`, x0+380*SCALE, y0+bh+20*SCALE);
  ctx.restore();
}
function renderHUD(now){
  const p=anim.active?Math.min(1,(now-anim.start)/anim.dur):1, t=easeOut(p);
  if(p>=1&&anim.active) anim.active=false;
  g.fillStyle='#04060a'; g.fillRect(0,0,HUD_W,HUD_H);
  g.fillStyle='#00ff66'; g.font=`bold ${Math.round(38*SCALE)}px ui-monospace,monospace`;
  g.fillText('C:\\> INTERSTELLAR COMET HUD // VR', 48*SCALE, 72*SCALE);

  const COLS=3, ROWS=2;
  const cellW=Math.floor((HUD_W-PAD*(COLS+1))/COLS);
  const cellH=Math.floor((HUD_H-110*SCALE-PAD*(ROWS+1))/ROWS);
  const X=c=> PAD + c*(cellW+PAD);
  const Y=r=> 90*SCALE + PAD + r*(cellH+PAD);

  frame(g, X(0),Y(0),cellW,cellH, `#${current.id} ${current.name} — Visible composition (proxies)`);
  capsules(g, X(0),Y(0)+24*SCALE,cellW,cellH-30*SCALE,current.composition,t);

  frame(g, X(1),Y(0),cellW,cellH,'Emission spectrum');
  spectrum(g, X(1),Y(0)+24*SCALE,cellW,cellH-30*SCALE,current.spectrum,t);

  frame(g, X(2),Y(0),cellW,cellH,'Velocity');
  donut(g, X(2),Y(0)+24*SCALE,cellW,cellH-30*SCALE,current.velocity.value,current.velocity.max,current.velocity.unit,current.velocity.ticks,null,t);

  frame(g, X(0),Y(1),cellW,cellH,'Mass (estimate)');
  massBar(g, X(0),Y(1)+24*SCALE,cellW,cellH-30*SCALE,current.mass.value,t);

  frame(g, X(1),Y(1),cellW,cellH,'Coolness index');
  donut(g, X(1),Y(1)+24*SCALE,cellW,cellH-30*SCALE,current.coolness.value,current.coolness.max,'%',[.25,.5,.75],'Coolness',t);

  frame(g, X(2),Y(1),cellW,cellH,'Data reliability');
  reliabilityStack(g, X(2),Y(1)+24*SCALE,cellW,cellH-30*SCALE,current.reliability,t);

  g.fillStyle='#aee8ff'; g.font=`${Math.round(18*SCALE)}px ui-monospace,monospace`;
  g.fillText(`STATUS: ONLINE  |  ${new Date().toLocaleTimeString()}`, 48*SCALE, HUD_H-18*SCALE);
}

/* =========================================================
   2) THREE / WebXR (без внешних examples)
   ========================================================= */
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true,canvas:Object.assign(document.createElement('canvas'),{id:'glcanvas'})});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
renderer.xr.enabled=true;
renderer.outputColorSpace=THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene(); scene.background=new THREE.Color(0x04060a);
const camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 50);
camera.position.set(0,1.6,0); scene.add(camera);

const holder=new THREE.Group(); scene.add(holder);

/* Панель + зум */
let PANEL_SCALE=1.0;
let CUR_DIST=1.7;
const MIN_DIST=1.1, MAX_DIST=2.5, MIN_SCALE=0.85, MAX_SCALE=1.6;

const PANEL_W=2.1, PANEL_H=1.25;
const hudPanel=new THREE.Mesh(new THREE.PlaneGeometry(PANEL_W, PANEL_H), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
holder.add(hudPanel);

const hudTex=new THREE.CanvasTexture(hudCanvas);
hudTex.colorSpace=THREE.SRGBColorSpace;
hudTex.generateMipmaps=false; hudTex.minFilter=THREE.LinearFilter; hudTex.magFilter=THREE.LinearFilter;
hudPanel.material.map=hudTex;

function placeInFront(dist=CUR_DIST){
  camera.updateMatrixWorld(true);
  holder.position.copy(camera.position);
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  holder.position.addScaledVector(forward, dist);
  holder.quaternion.copy(camera.quaternion);
}
function applyZoom(dir){
  PANEL_SCALE = THREE.MathUtils.clamp(PANEL_SCALE + dir*0.08, MIN_SCALE, MAX_SCALE);
  CUR_DIST    = THREE.MathUtils.clamp(CUR_DIST   - dir*0.08, MIN_DIST, MAX_DIST);
  hudPanel.scale.setScalar(PANEL_SCALE);
  placeInFront(CUR_DIST);
}
placeInFront(CUR_DIST);

/* Примитивные контроллеры: луч + маркер-сфера (видно ВСЕГДА) */
function makeController(i){
  const c = renderer.xr.getController(i);
  const rayGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
  const ray = new THREE.Line(rayGeom, new THREE.LineBasicMaterial({color:0x66ccff})); ray.scale.z=8; c.add(ray);
  const dot = new THREE.Mesh(new THREE.SphereGeometry(0.01,12,12), new THREE.MeshBasicMaterial({color:0xffffff})); dot.position.z=-0.05; c.add(dot);
  scene.add(c); return c;
}
const controller1 = makeController(0);
const controller2 = makeController(1);

/* 3D-кнопки (fallback, если overlay нет) */
const ui3D = new THREE.Group(); ui3D.visible=false; holder.add(ui3D);

function makeLabelMat(text){
  const cw=512,ch=128, c=document.createElement('canvas'); c.width=cw; c.height=ch; const ctx=c.getContext('2d');
  // Без roundRect — рисуем руками (чтобы не падать в старых браузерах)
  ctx.fillStyle='#0e1720'; ctx.strokeStyle='rgba(174,232,255,.35)'; ctx.lineWidth=4;
  const r=22, x=6, y=6, w=cw-12, h=ch-12;
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#aee8ff'; ctx.font='bold 44px ui-monospace,monospace';
  const tw=ctx.measureText(text).width; ctx.fillText(text,(cw-tw)/2,82);
  const tex=new THREE.CanvasTexture(c); tex.colorSpace=THREE.SRGBColorSpace; return new THREE.MeshBasicMaterial({map:tex,transparent:true});
}
function make3DButton(text, cb){
  const m=makeLabelMat(text); const g=new THREE.PlaneGeometry(0.48,0.12); const mesh=new THREE.Mesh(g,m);
  mesh.userData.onClick=cb; return mesh;
}
const b1 = make3DButton('1I/ʻOumuamua', ()=>setComet('1I'));
const b2 = make3DButton('2I/Borisov',   ()=>setComet('2I'));
const b3 = make3DButton('3I/ATLAS',     ()=>setComet('3I'));
const bz = make3DButton('Zoom −',       ()=>applyZoom(-1));
const bZ = make3DButton('Zoom +',       ()=>applyZoom(+1));
ui3D.add(b1,b2,b3,bz,bZ);
function layout3D(){
  ui3D.position.set(0,0.8,-0.01);
  b1.position.set(-0.6, 0, 0);
  b2.position.set( 0.0, 0, 0);
  b3.position.set( 0.6, 0, 0);
  bz.position.set(-0.25,-0.18,0);
  bZ.position.set( 0.25,-0.18,0);
}
layout3D();

/* Raycast по 3D-кнопкам */
const raycaster=new THREE.Raycaster(); const tmp=new THREE.Matrix4();
function hitButtons(ctrl){
  if(!ui3D.visible) return;
  tmp.identity().extractRotation(ctrl.matrixWorld);
  const origin=new THREE.Vector3().setFromMatrixPosition(ctrl.matrixWorld);
  const dir=new THREE.Vector3(0,0,-1).applyMatrix4(tmp);
  raycaster.set(origin,dir);
  const hits=raycaster.intersectObjects(ui3D.children,false);
  if(hits.length>0){ const obj=hits[0].object; if(obj.userData.onClick) obj.userData.onClick(); }
}
controller1.addEventListener('selectstart', ()=>hitButtons(controller1));
controller2.addEventListener('selectstart', ()=>hitButtons(controller2));

/* DOM-кнопки */
function setComet(id){
  document.querySelectorAll('#cometButtons button').forEach(b=>b.classList.remove('active'));
  const btn=document.querySelector(`#cometButtons button[data-id="${id}"]`); if(btn) btn.classList.add('active');
  current=PASSPORTS[id]; trigger(performance.now());
}
document.getElementById('cometButtons').addEventListener('click',e=>{
  const b=e.target.closest('button[data-id]'); if(!b) return; setComet(b.dataset.id);
});
document.getElementById('btnRecenter').onclick=()=>placeInFront(CUR_DIST);
document.getElementById('btnZoomIn').onclick = ()=>applyZoom(+1);
document.getElementById('btnZoomOut').onclick= ()=>applyZoom(-1);
let BIG=false;
document.getElementById('btnBig').onclick=()=>{
  BIG=!BIG; document.getElementById('btnBig').textContent=BIG?'BIG MODE: ON':'BIG MODE: OFF';
  PANEL_SCALE=BIG?1.32:1.00; CUR_DIST=BIG?1.45:1.70; hudPanel.scale.setScalar(PANEL_SCALE); placeInFront(CUR_DIST);
};

/* VR-кнопка с fallback dom-overlay optional */
function createVRButton(renderer, overlayRoot){
  const btn=document.createElement('button');
  btn.textContent='Enter VR';
  btn.style.cssText='padding:10px 14px;border-radius:10px;background:#123040;color:#dff8ff;border:1px solid #45c0d4;cursor:pointer';
  document.getElementById('vrDock').appendChild(btn);
  let session=null;

  async function start(requireOverlay){
    const init={
      requiredFeatures:['local-floor'],
      optionalFeatures:['hand-tracking','layers','dom-overlay'],
      domOverlay:{root:overlayRoot}
    };
    if(requireOverlay){ init.requiredFeatures=['local-floor','dom-overlay']; }
    const s=await navigator.xr.requestSession('immersive-vr',init);
    await renderer.xr.setSession(s); return s;
  }

  btn.addEventListener('click', async ()=>{
    if(session){ await session.end(); return; }
    try{
      let s; try { s=await start(true); } catch(_){ s=await start(false); }
      session=s; btn.textContent='Exit VR';
      // включаем клики канваса в VR (для WebXR подсистемы), но HTML-UI всё равно сверху как overlay
      renderer.domElement.style.pointerEvents='auto';
      const hasOverlay = !!(s.domOverlayState && s.domOverlayState.type);
      document.getElementById('overlayWarn').style.display = hasOverlay ? 'none' : 'block';
      ui3D.visible = !hasOverlay;
      s.addEventListener('end', ()=>{
        session=null; btn.textContent='Enter VR';
        // вернём «некликабельность» канваса в обычном режиме
        renderer.domElement.style.pointerEvents='none';
        document.getElementById('overlayWarn').style.display='none';
        ui3D.visible=false;
      });
    }catch(err){
      console.error(err); btn.textContent='VR ERROR';
    }
  });
}
createVRButton(renderer, document.getElementById('ui'));

/* Ресайз и рендер */
addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  placeInFront(CUR_DIST);
});
let last=0, HUD_INTERVAL=1000/30;
renderer.setAnimationLoop((t)=>{
  if(t-last>HUD_INTERVAL){ renderHUD(t); hudTex.needsUpdate=true; last=t; }
  renderer.render(scene,camera);
});
trigger(performance.now());
</script>
</body>
</html>
