<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>VR HUD — Comets (styled bars, fast)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no">
  <meta name="theme-color" content="#04060a">
  <style>
    html,body{margin:0;height:100%;background:#04060a;color:#aee8ff;font-family:ui-monospace,Consolas,Monaco,monospace}
    #ui{position:fixed;left:12px;bottom:12px;z-index:10}
    #ui button{padding:6px 10px;margin-right:8px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <button id="btnVR">Enter VR</button>
    <button id="btnCurve">Curved ON</button>
    <button id="btnRecenter">Recenter</button>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { VRButton } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js";

    // ---------- ПАРАМЕТРЫ КАЧЕСТВА ----------
    const params = new URLSearchParams(location.search);
    const res = (params.get('res')||'mid').toLowerCase(); // low|mid|hi
    const RESOLUTIONS = { low:[1280,720], mid:[1536,864], hi:[2048,1024] };
    const [HUD_W, HUD_H] = RESOLUTIONS[res] ?? RESOLUTIONS.mid;

    // ---------- ПАНЕЛИ / ДАННЫЕ ----------
    // уникальные номера и подписи — сюда потом подставим реальные кометы
    const PANELS = [
      { id:1, label:"12P/Pons–Brooks" },
      { id:2, label:"1P/Halley" },
      { id:3, label:"C/2023 A3 (Tsuchinshan–ATLAS)" }
    ];
    const COLS = Math.min(3, PANELS.length);
    const ROWS = Math.ceil(PANELS.length / COLS);
    const PAD  = 40;

    // скользящий буфер (чуть короче ради скорости)
    const SERIES_LEN = 48;
    const buffers = PANELS.map(()=> new Array(SERIES_LEN).fill(0.3));

    // простая «подпитка» данных; позже сюда встанут реальные значения
    setInterval(()=>{
      buffers.forEach(arr=>{
        arr.shift();
        const last = arr[arr.length-1] ?? 0.5;
        const jitter = (Math.random()-0.5)*0.06;
        arr.push(Math.max(0, Math.min(1, last + jitter)));
      });
    }, 120);

    // ---------- HUD CANVAS (+ Offscreen) ----------
    const useOffscreen = typeof OffscreenCanvas !== 'undefined';
    const hudCanvas = useOffscreen ? new OffscreenCanvas(HUD_W, HUD_H)
                                   : Object.assign(document.createElement('canvas'), {width:HUD_W, height:HUD_H});
    const g = hudCanvas.getContext('2d');

    // ---------- СТИЛЬ БАР-ГРАФИКА как в прошлой работе ----------
    // (сетка, закруглённые бары с градиентом) — адаптация под VR
    function drawBarsStyled(ctx, w, h, values){
      // фон
      ctx.fillStyle = '#071018';
      ctx.fillRect(-8,-8,w+16,h+16);
      // рамка (пунктир)
      ctx.strokeStyle = '#00aa55'; ctx.lineWidth = 2; ctx.setLineDash([8,6]);
      ctx.strokeRect(-8.5,-8.5,w+17,h+17); ctx.setLineDash([]);

      // сетка
      ctx.strokeStyle = 'rgba(0,224,255,.12)'; ctx.lineWidth = 1;
      for(let x=0; x<w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

      // бары
      const N = values.length;
      const step = (w-32)/N, barW = step*0.78;
      const grad = (x,y,wid) => {
        const g2 = ctx.createLinearGradient(x, y, x+Math.max(1,wid), y);
        g2.addColorStop(0,'rgba(0,180,220,.25)');
        g2.addColorStop(0.5,'rgba(167,245,255,.65)');
        g2.addColorStop(1,'rgba(0,180,220,.25)');
        return g2;
      };
      ctx.strokeStyle = 'rgba(0,224,255,.55)';

      for(let i=0;i<N;i++){
        const x = 16 + i*step;
        const val = 16 + values[i]*(h-80);
        const y = h - 24 - val;
        const r = 7, bh = val, bw = barW;

        ctx.fillStyle = grad(x,y,bw);
        // path c закруглением
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.lineTo(x+bw-r,y);
        ctx.quadraticCurveTo(x+bw,y, x+bw,y+r);
        ctx.lineTo(x+bw, y+bh-r);
        ctx.quadraticCurveTo(x+bw,y+bh, x+bw-r,y+bh);
        ctx.lineTo(x+r,y+bh);
        ctx.quadraticCurveTo(x,y+bh, x,y+bh-r);
        ctx.lineTo(x,y+r);
        ctx.quadraticCurveTo(x,y, x+r,y);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    }

    // ---------- СБОРКА HUD ----------
    function renderHUD(){
      g.fillStyle = '#04060a';
      g.fillRect(0,0,HUD_W,HUD_H);

      // заголовок
      g.fillStyle = '#00ff66';
      g.font = 'bold 48px ui-monospace,monospace';
      g.fillText('C:\\> INTERSTELLAR COMET HUD // VR', 48, 88);

      const cellW = Math.floor((HUD_W - PAD*(COLS+1)) / COLS);
      const cellH = Math.floor((HUD_H - 140 - PAD*(ROWS+1)) / ROWS);

      PANELS.forEach((p, idx)=>{
        const col = idx % COLS, row = (idx/COLS)|0;
        const x = PAD + col*(cellW + PAD);
        const y = 120 + PAD + row*(cellH + PAD);

        // подпись #id + имя
        g.fillStyle = '#aee8ff';
        g.font = '24px ui-monospace,monospace';
        g.fillText(`#${p.id} ${p.label}`, x+8, y+28);

        // сам график (перенос оси в начало ячейки)
        g.save(); g.translate(x, y);
        drawBarsStyled(g, cellW, cellH, buffers[idx]);
        g.restore();
      });

      // статус
      g.fillStyle = '#aee8ff';
      g.font = '20px ui-monospace,monospace';
      g.fillText(`STATUS: ONLINE  |  ${new Date().toLocaleTimeString()}`, 48, HUD_H-36);
    }

    // ---------- THREE / XR ----------
    const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);
    document.getElementById('btnVR').replaceWith(VRButton.createButton(renderer));

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x04060a);
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 50);
    camera.position.set(0,1.6,0); scene.add(camera);

    // изогнутая панель (по умолчанию ON)
    let CURVED = true, RADIUS = 1.2, PANEL_W=1.9, PANEL_H=1.05;
    function buildPanelGeometry(curved=true, w=PANEL_W, h=PANEL_H, r=RADIUS){
      if (!curved) return new THREE.PlaneGeometry(w, h);
      const arc = w / r; const thetaStart = Math.PI/2 - arc/2;
      return new THREE.CylinderGeometry(r, r, h, 64, 1, true, thetaStart, arc);
    }

    const hudTexture = new THREE.CanvasTexture(hudCanvas);
    hudTexture.colorSpace = THREE.SRGBColorSpace;
    // быстрее на Quest 2:
    hudTexture.generateMipmaps = false;
    hudTexture.minFilter = THREE.LinearFilter;
    hudTexture.magFilter = THREE.LinearFilter;
    hudTexture.anisotropy = Math.min(4, renderer.capabilities.getMaxAnisotropy());

    const hudMaterial = new THREE.MeshBasicMaterial({map:hudTexture, side:THREE.DoubleSide});
    const hudPanel = new THREE.Mesh(buildPanelGeometry(CURVED), hudMaterial);
    hudPanel.position.set(0,1.6,-1.6);
    if (CURVED) hudPanel.rotation.y = Math.PI;
    scene.add(hudPanel);

    document.getElementById('btnCurve').onclick = ()=>{
      CURVED = !CURVED;
      document.getElementById('btnCurve').textContent = CURVED ? 'Curved ON' : 'Curved OFF';
      hudPanel.geometry.dispose();
      hudPanel.geometry = buildPanelGeometry(CURVED);
      hudPanel.rotation.y = CURVED ? Math.PI : 0;
    };
    document.getElementById('btnRecenter').onclick = ()=> hudPanel.position.set(0,1.6,-1.6);

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ---------- Рендер-цикл (30 FPS для HUD) ----------
    let lastHudUpdate = 0;
    const HUD_INTERVAL = 1000/30; // 30 fps на обновление текстуры
    renderer.setAnimationLoop((timeMS)=>{
      if (timeMS - lastHudUpdate > HUD_INTERVAL){
        renderHUD();
        hudTexture.needsUpdate = true;
        lastHudUpdate = timeMS;
      }
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
